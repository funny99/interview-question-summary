# 闭包
## 定义
- 红宝书里面说：“闭包就是指有权访问另一个函数作用域中的变量的函数“。
- 圣经宝典里面说：”从技术的角度来讲，所有的JavaScript函数都是闭包；它们都是对象，它们都关联到作用域链“。
- You dont't know JS say:"当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是当前词法作用域之外执行"。

**闭包是指有权访问另一个函数作用域中变量的函数**

只要存在调用内部函数的可能，js就需要保存被引用的函数。js运行时需要跟踪引用到的这个内部函数的所有变量，一直到最后一个变量废除，js的GC才能回收这些变量的内存空间。

## 形成闭包的原因
内部的函数存在外部作用域的引用就会导致闭包。

## 闭包变量存储的位置
**闭包中的变量存储的位置是堆内存。**

假如闭包中的变量存储在栈内存中，那么栈的回收 会把处于栈顶的变量自动回收。所以闭包中的变量如果处于栈中那么变量被销毁后，闭包中的变量就没有了。所以闭包引用的变量是出于堆内存中的。

## 作用
可以读取函数内部的变量;让这些变量的值始终保持在内存中。

- 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
- 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化

## 使用场景
- return回一个函数
- 函数作为参数
- IIFE（自执行函数）
- 循环赋值
- 使用回调函数就是在使用闭包
- 节流防抖
- 柯里化实现

## 注意点
- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
- 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

这里简单说一下，为什么使用闭包时变量不会被垃圾回收机制收销毁呢，这里需要了解一下JS垃圾回收机制：
JS规定在一个函数作用域内，程序执行完以后变量就会被销毁，这样可节省内存；使用闭包时，按照作用域链的特点，闭包（函数）外面的变量不会被销毁，因为函数会一直被调用，所以一直存在，如果闭包使用过多会造成内存泄漏。

> [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

> [那些高级/资深的前端是如何回答JavaScript面试题的 （一）](https://juejin.cn/post/6971727286856843295)

# JS 堆栈内存释放
**堆内存**：存储引用类型值，对象类型就是键值对，函数就是代码字符串。

**堆内存释放**：将引用类型的空间地址变量赋值成 null，或没有变量占用堆内存了浏览器就会释放掉这个地址

**栈内存**：提供代码执行的环境和存储基本类型值。

**栈内存释放**：一般当函数执行完后函数的私有作用域就会被释放掉。

但栈内存的释放也有特殊情况：① 函数执行完，但是函数的私有作用域内有内容被栈外的变量还在使用的，栈内存就不能释放里面的基本值也就不会被释放。② 全局下的栈内存只有页面被关闭的时候才会被释放

# 变量提升
## 定义
```
/* 你应该见过下面的类似代码，那你知道这是为什么*/
console.log(a)  // undefined
var a = 10
```
> 变量提升是当栈内存作用域形成时，JS代码执行前，浏览器会将带有var, function关键字的变量提前进行声明 declare(值默认就是 undefined)，定义 defined(就是赋值操作)，这种预先处理的机制就叫做变量提升机制也叫预定义。
在变量提升阶段：带 var 的只声明还没有被定义，带 function 的已经声明和定义。所以在代码执行前有带 var 的就提前声明，比如这里的 a 就赋值成 undefined，在代码执行过程中遇到创建函数的代码浏览器会直接跳过。


> [彻底解决 JS 变量提升| 一题一图，超详细包教包会😉](https://juejin.cn/post/6933377315573497864)

# js内存泄漏
## 定义
内存泄漏可以定义为程序不再使用或不需要的一块内存，但是由于某种原因没有被释放仍然被不必要的占有。
在代码中创建对象和变量会占用内存，但是javaScript是有自己的内存回收机制，可以确定那些变量不再需要，并将其清除。但是当你的代码存在逻辑缺陷的时候，你以为你已经不需要，但是程序中还存在着引用，导致程序运行完后并没有合适的回收所占用的空间，导致内存不断的占用，运行的时间越长占用的就越多，随之出现的是，性能不佳，高延迟，频繁崩溃。

## 原因
虽然前端有垃圾回收机制，但当某块无用的内存，却无法被垃圾回收机制认为是垃圾时，也就发生内存泄漏了
而垃圾回收机制通常是使用标志清除策略，简单说，也就是引用从根节点开始是否可达来判定是否是垃圾
上面是发生内存泄漏的根本原因，直接原因则是，当不同生命周期的两个东西相互通信时，一方生命到期该回收了，却被另一方还持有时，也就发生内存泄漏了

## 场景
- 意外的全局变量
- 遗忘的定时器
- 使用不当的闭包
- 遗漏的DOM元素
- 网络回调

> [js 内存泄漏场景、如何监控以及分析](https://juejin.cn/post/6844904048961781774)

> [彻底掌握js内存泄漏以及如何避免](https://juejin.cn/post/6844903917986267143)

# script 标签中 defer 和 async 的区别？
script标签会阻碍html解析，只有下载好并执行完脚本才会继续解析html。
- async： 解析html过程中进行脚本的异步下载，下载完成立马执行，有可能会阻断html的解析
- defer：完全不会阻碍html的解析，解析完成后再按照顺序执行脚本
![](./images/script-async-defer.awebp)

> [图解 script 标签中的 async 和 defer 属性](https://juejin.cn/post/6894629999215640583)

# 参考
- [JS 闭包经典使用场景和含闭包必刷题](https://juejin.cn/post/6937469222251560990)